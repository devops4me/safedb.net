# The open key library generates keys, it stores their salts, it produces differing
# representations of the keys (like base64 for storage and binary for encrypting).
#
# == Key Class Names their and Responsibility
#
# The 5 core key classes in the open key library are
#
# - {Key} represents keys in bits, binary and base 64 formats
# - {Key64} for converting from to and between base 64 characters
# - {Key256} uses key derivation functions to produce high entropy keys
# - {KeyIO} reads and writes key metadata (like salts) from/to persistent storage
# - {KeyCycle} for creating and locking the keys that underpin the security
#
# == The 5 Core Key Classes
#
#     Key              To initialize with a 264 binary bit string. To hold the
#                      key and represent it when requested
#                       - as a 264 bit binary bit string
#                       - as a 256 bit binary bit string
#                       - as a 256 bit raw bytes encryption key
#                       - as a YACHT64 formatted string
#
#     Key64            To map in and out of the Yacht64 character set - from and to
#                       - a binary bit string sequence
#                       - a Base64 character encoding
#                       - a UrlSafe Base64 character encoding
#                       - a Radix64 character encoding
#
#     Key256           It generates a key in 3 different and important ways. It can
#                      generate
#
#                        (a) from_password
#                        (b) from_random (or it can)
#                        (c) regenerate
#
#                      When generating from a password it takes a dictionary with
#                      a pre-tailored "section" and writes BCrypt and Pbkdf2 salts
#                      into it.
#
#                      When generating random it kicks of by creating a 55 byte
#                      random key fo BCrypt and a 64 byte random key for Pbkdf2.
#                      It then calls upon generate_from_password.
#
#                      When regenerating it queries the dictionary provided at the
#                      pre-tailored "section" for the BCrypt and Pbkdf2 salts and
#                      then uses input passwords (be they human randomly sourced)
#                      and regenerates the keys it produced at an earlier sitting.
#
#     KeyIO            KeyIO is instantiated with a folder path and a "key reference".
#                      KeyIO will then manage writing to and rereading from the structure
#                      hel inside th efile. The file is named (primarily) by the
#                      reference string.
#
#     KeyCycle         KeyLifeCycle implements the merry go round that palms off
#                      responsibility to the intra-session cycle and then back again
#                      to ever rotary inter-session(ary) cycle.
###########            Maybe think of a method where we pass in
###########            2 secrets - 1 human and 1 55 random bytes (session)
###########
###########            1  another 55 random key is created (the actual encryption key)
###########            2  then the above key is encrypted TWICE (2 diff salts and keys)
###########            3  Once by key from human password
###########            4  Once by key from machine password
###########            5  then the key from 1 is returned
###########            6  caller encrypts file .................... (go 4 it)


# Generates a 256 bit symmetric encryption key derived from a random
# seed sequence of 55 bytes. These 55 bytes are then fed into the
# {from_password} key derivation function and processed in a similar
# way to if a human had generated the string.
#


# <b>Key derivation functions</b> exist to convert <b>low entropy</b> human
# created passwords into a high entropy key that is computationally difficult
# to acquire through brute force.
#
# == SafeDb's Underlying Security Strategy
#
# <b>Randomly generate a 256 bit encryption key and encrypt it</b> with a key
# derived from a human password and generated by at least two cryptographic
# workhorses known as <b>key derivation functions</b>.
#
# The encryption key (encrypted by the one derived from a human password) sits
# at the beginning of a long chain of keys and encryption - so much so that the
# crypt material being outputted for storage is all but worthless to anyone but
# its rightful owner.
#
# == Key Size vs Crack Time
#
# Cracking a 256 bit key would need roughly 2^255 iterations (half the space)
# and this is akin to the number of atoms in the known universe.
#
# <b>The human key can put security at risk.</b>
#
# The rule of thumb is that a 40 character password with a good spread of the
# roughly 90 typable characters, would produce security equivalent to that of
# an AES 256bit key. As the password size and entropy drop, so does the security,
# exponentially.
#
# As human generated passwords have a relatively small key space, key derivation
# functions must be slow to compute with any implementation.
#
# == Key Derivation Functions for Command Line Apps
#
# A command line app (with no recourse to a central server) uses a Key
# Derivation Function (like BCrypt, Aaron2 or PBKD2) in a manner different
# to that employed by server side software.
#
# - server side passwords are hashed then both salt and hash are persisted
# - command line apps do not store the key - they only store the salt
# - both throw away the original password
#
# == One Key | One Session | One Crypt
#
# Command line apps use the derived key to <b>symmetrically encrypt and decrypt</b>
# one and only one 48 character key and a new key is derived at the beginning
# of every session.
#
# At the end of the session <b>all material encrypted by the outgoing key</b>
# is removed. This aggressive key rotation strategy leaves no stone unturned in
# the quest for ultimate security.
#
# == SafeDb's CLI Key Derivation Architecture
#
# SafeDb never accesses another server and giving its users total control
# of their secret crypted materials. It strengthens the key derivation process
# in three important ways.
#
# - [1] it does not store the key nor does it store the password
#
# - [2] a new master key is generated for every session only to hold the master index file
#
# - [3] it uses both <b>BCrypt</b> (Blowfish Crypt) and the indefatigable <b>PBKD2</b>


  # After a successful initialization, the application instance is linked to a keystore
  # whose contents are responsible for securing the application instance database.
  #
  # To ascertain what needs to be done to bridge the gap to full initialization the
  # app needs to know 3 things from the KeyApi. These things are
  #
  # - the ID of this app instance on the machine
  # - if a keystore been associated with this ID
  # - whether the keystore secures the app database
  #
  # The answers dictate the steps that need to be undertaken to bring the database of
  # the application instance under the secure wing of the KeyApi.
  #
  #
  # == 1. What is the App Instance ID on this Machine?
  #
  # The KeyApi uses the "just given" application reference and the machine environment to
  # respond with a <b>digested identifier</b> binding the application instance to the
  # present machine (workstation).
  #
  #
  # == 2. Has a Keystore been associated with this ID?
  #
  # The application's configuration manager is asked to find an associated KeyStore ID
  # mapped against the app/machine id garnered by question 1.
  #
  # <b>No it has not!</b>
  #
  # If <b>NO</b> then a KeyStore ID is acquired <b>either from the init command's parameter</b>,
  # or a <b>suitable default</b>. This new association between the app/machine ID and the
  # KeyStore ID is then stored so the answer next time will be <b>YES</b>.
  #
  # <b>Yes it has!</b>
  #
  # Great - we now submit the KeyStore ID to the KeyApi so that it may answer question 3.
  #
  #
  # == 3. Does the keystore secure the app instance database?
  #
  # For the KeyApi to answer, it needs the App's Instance ID and the KeyStore ID.
  #
  # <b>Not Yet!</b> Now <b>NO</b> means this application instance's database has not been
  # brought under the protection of the KeyApi's multi-layered security net. For this it
  # needs
  #
  # - the KeyStore ID
  # - the application instance reference
  # - the plaintext secret from which nothing of the host survives
  # - the current application database plaintext
  #
  # <b>Yes it does!</b> If the app db keys <b>have been instantiated</b> and the client app is
  # <b>sitting pretty</b> in possession of the database ciphertext, no more needs doing.
